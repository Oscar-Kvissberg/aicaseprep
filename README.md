# RAG Framework with Next.js and Supabase

This framework provides a foundation for building RAG (Retrieval-Augmented Generation) applications using Next.js and Supabase. It includes features like PDF processing, vector embeddings, custom prompts, and Q&A examples.

## Features

- 📄 PDF Upload and Processing
- 🔍 Vector Search with OpenAI Embeddings
- 💬 Chat Interface with Context
- 📝 Custom System Prompts
- 🤖 Q&A Examples Management
- 🔐 Google OAuth Authentication
- 📊 Document Processing Status

## Setup Instructions

### 1. Create a Supabase Project

1. Go to [Supabase](https://supabase.com)
2. Create a new project
3. Save your project URL and anon key for environment variables

### 2. Database Setup

Run the following SQL commands in your Supabase SQL Editor to set up all necessary tables and functions:

```sql
-- Enable pgvector extension
create extension if not exists vector;

-- Create vectors table for storing document embeddings
create table vectors (
  id bigint generated by default as identity primary key,
  content text,
  metadata jsonb,
  embedding vector(1536),
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Enable RLS for vectors
alter table vectors enable row level security;

-- Create policy for selecting vectors
create policy "Users can view their own vectors" on vectors
  for select using (auth.jwt() ->> 'email' = (metadata->>'user_email')::text);

-- Create policy for inserting vectors
create policy "Users can insert their own vectors" on vectors
  for insert with check (auth.jwt() ->> 'email' = (metadata->>'user_email')::text);

-- Create index for faster similarity search
create index on vectors using ivfflat (embedding vector_cosine_ops) with (lists = 100);

-- Create custom prompts table
create table custom_prompts (
  id bigint generated by default as identity primary key,
  user_email text not null,
  prompt_text text not null,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Enable RLS for custom prompts
alter table custom_prompts enable row level security;

-- Create policies for custom prompts
create policy "Users can view their own prompts" on custom_prompts
  for select using (auth.jwt() ->> 'email' = user_email);

create policy "Users can insert their own prompts" on custom_prompts
  for insert with check (auth.jwt() ->> 'email' = user_email);

-- Create file status table
create table file_status (
  id bigint generated by default as identity primary key,
  filename text not null,
  user_email text not null,
  has_vectors boolean not null default false,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Enable RLS for file status
alter table file_status enable row level security;

-- Create policies for file status
create policy "Users can view their own files" on file_status
  for select using (auth.jwt() ->> 'email' = user_email);

create policy "Users can insert their own files" on file_status
  for insert with check (auth.jwt() ->> 'email' = user_email);

create policy "Users can update their own files" on file_status
  for update using (auth.jwt() ->> 'email' = user_email);

-- Create QA examples table
create table qa_examples (
  id bigint generated by default as identity primary key,
  user_email text not null,
  question text not null,
  answer text not null,
  embedding vector(1536),
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Enable RLS for QA examples
alter table qa_examples enable row level security;

-- Create policies for QA examples
create policy "Users can view their own QA examples" on qa_examples
  for select using (auth.jwt() ->> 'email' = user_email);

create policy "Users can insert their own QA examples" on qa_examples
  for insert with check (auth.jwt() ->> 'email' = user_email);

create policy "Users can delete their own QA examples" on qa_examples
  for delete using (auth.jwt() ->> 'email' = user_email);

-- Create function for matching documents
create or replace function match_documents(
  query_embedding vector(1536),
  match_threshold float,
  match_count int
)
returns table (
  id bigint,
  content text,
  metadata jsonb,
  similarity float
)
language plpgsql
as $$
begin
  return query
  select
    vectors.id,
    vectors.content,
    vectors.metadata,
    1 - (vectors.embedding <=> query_embedding) as similarity
  from vectors
  where 1 - (vectors.embedding <=> query_embedding) > match_threshold
  order by vectors.embedding <=> query_embedding
  limit match_count;
end;
$$;

-- Create function for matching QA examples
create or replace function match_qa_examples(
  query_embedding vector(1536),
  match_threshold float,
  match_count int,
  p_user_email text
)
returns table (
  id bigint,
  question text,
  answer text,
  similarity float
)
language plpgsql
as $$
begin
  return query
  select
    qa.id,
    qa.question,
    qa.answer,
    1 - (qa.embedding <=> query_embedding) as similarity
  from qa_examples qa
  where 1 - (qa.embedding <=> query_embedding) > match_threshold
    and qa.user_email = p_user_email
  order by qa.embedding <=> query_embedding
  limit match_count;
end;
$$;
```

### 3. Storage Setup

1. Create a new storage bucket named 'pdfs'
2. Set up the following storage policies:

```sql
-- Allow users to upload files
create policy "Users can upload files"
on storage.objects for insert
with check (
  auth.role() = 'authenticated' AND
  bucket_id = 'pdfs' AND
  (storage.foldername(name))[1] = auth.jwt() ->> 'email'
);

-- Allow users to read their own files
create policy "Users can read their own files"
on storage.objects for select
using (
  auth.role() = 'authenticated' AND
  bucket_id = 'pdfs' AND
  (storage.foldername(name))[1] = auth.jwt() ->> 'email'
);

-- Allow users to delete their own files
create policy "Users can delete their own files"
on storage.objects for delete
using (
  auth.role() = 'authenticated' AND
  bucket_id = 'pdfs' AND
  (storage.foldername(name))[1] = auth.jwt() ->> 'email'
);
```

### 4. Environment Variables

Create a `.env.local` file with the following variables:

```env
# Supabase Configuration
NEXT_PUBLIC_SUPABASE_URL=your_supabase_url
NEXT_PUBLIC_SUPABASE_ANON_KEY=your_supabase_anon_key
SUPABASE_SERVICE_ROLE_KEY=your_supabase_service_role_key

# Google OAuth Configuration
GOOGLE_CLIENT_ID=your_google_client_id
GOOGLE_CLIENT_SECRET=your_google_client_secret

# OpenAI Configuration
OPENAI_API_KEY=your_openai_api_key

# NextAuth Configuration
NEXTAUTH_SECRET=your_nextauth_secret
NEXTAUTH_URL=http://localhost:3000
```

### 5. Install Dependencies

```bash
npm install
```

### 6. Run the Development Server

```bash
npm run dev
```

## Usage

1. Log in using Google OAuth
2. Upload PDF documents in the Upload tab
3. Create custom system prompts in the Prompts tab
4. Add Q&A examples in the Q&A tab
5. Chat with your documents in the Chat tab

## Features Explanation

### Vector Search
- Documents and Q&A examples are converted to embeddings using OpenAI's embedding model
- Similarity search is performed using pgvector's cosine similarity
- Results are filtered by similarity threshold (default: 0.78)

### PDF Processing
- PDFs are stored in Supabase Storage
- Text is extracted and converted to embeddings
- Processing status is tracked in the file_status table

### Custom Prompts
- Users can create and save custom system prompts
- Prompts can be activated to modify the AI's behavior

### Q&A Examples
- Users can store example Q&A pairs
- Examples are used for context when similar questions are asked
- Similarity matching uses the same embedding model as documents

## Security

- Row Level Security (RLS) ensures users can only access their own data
- Storage policies restrict access to user-specific folders
- All API routes require authentication
- Environment variables protect sensitive credentials

## Contributing

Feel free to submit issues and enhancement requests!

## License

MIT
